import { tabbable as v } from "tabbable";
import { isTab as x, isTabAndShift as U, focusNext as D, focusPrev as S } from "@storefront-ui/shared";
import { useState as g, useCallback as G, useEffect as N } from "react";
var O = /* @__PURE__ */ ((e) => (e.autofocus = "autofocus", e.container = "container", e))(O || {});
const P = {
  trapTabs: !0,
  activeState: !0,
  initialFocus: 0,
  initialFocusContainerFallback: !1,
  arrowKeysOn: !1,
  arrowKeysLeftRight: !1,
  arrowKeysUpDown: !1
}, z = (e, C) => {
  const {
    trapTabs: p,
    arrowFocusGroupSelector: f,
    includeContainer: b,
    activeState: k,
    initialFocus: s,
    arrowKeysOn: F,
    arrowKeysLeftRight: m,
    arrowKeysUpDown: A,
    initialFocusContainerFallback: E
  } = {
    ...P,
    ...C
  }, [i, L] = g(), [u, l] = g([]), n = ({
    event: r,
    additionalData: t
  }) => S({
    current: i,
    focusables: u,
    event: r,
    ...t
  }), a = ({
    event: r,
    additionalData: t
  }) => D({
    current: i,
    focusables: u,
    event: r,
    ...t
  }), w = G(
    (r) => {
      var c;
      const o = f && ((c = e.current) == null ? void 0 : c.querySelector(f)) ? { arrowFocusGroupSelector: f } : {};
      F && (r.key === "ArrowLeft" || r.key === "ArrowUp") && n({ additionalData: o }), F && (r.key === "ArrowRight" || r.key === "ArrowDown") && a({ additionalData: o }), m && r.key === "ArrowLeft" && n({ additionalData: o }), m && r.key === "ArrowRight" && a({ additionalData: o }), A && r.key === "ArrowUp" && n({ additionalData: o }), A && r.key === "ArrowDown" && a({ additionalData: o }), p && x(r) && a({ event: r }), p && U(r) && n({ event: r });
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [i]
  ), h = () => {
    const r = document.activeElement;
    L(r);
  }, T = () => {
    var r, t;
    (r = e.current) == null || r.removeEventListener("keydown", w), (t = e.current) == null || t.removeEventListener("focus", h, !0);
  };
  return N(() => {
    var r, t, o, c;
    if (e.current && k) {
      (r = e.current) == null || r.addEventListener("focus", h, !0), (t = e.current) == null || t.addEventListener("keydown", w);
      let y = !1;
      if (l(v(e.current, { includeContainer: b })), typeof s == "number")
        u[s] ? (o = u[s]) == null || o.focus() : (console.error(`There is no element with given index ${s}`), y = !0);
      else if (s === "autofocus") {
        const K = u.find((d) => d == null ? void 0 : d.hasAttribute("autofocus"));
        K ? K.focus() : y = !0;
      }
      (E && y || s === "container") && ((c = e.current) == null || c.focus());
    } else
      l([]), L(void 0);
    return T;
  }, [e.current, k, w]), {
    current: i,
    focusables: u,
    focusNext: D,
    focusPrev: S,
    updateFocusableElements: () => {
      e.current && l(v(e.current, { includeContainer: b }));
    }
  };
};
export {
  O as InitialFocusType,
  z as useTrapFocus
};
