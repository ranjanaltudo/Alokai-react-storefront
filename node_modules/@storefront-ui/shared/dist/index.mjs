var D = Object.defineProperty;
var E = (t, e, r) => e in t ? D(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r;
var a = (t, e, r) => (E(t, typeof e != "symbol" ? e + "" : e, r), r);
var u = /* @__PURE__ */ ((t) => (t.vertical = "vertical", t.horizontal = "horizontal", t))(u || {}), T = /* @__PURE__ */ ((t) => (t.none = "none", t.floating = "floating", t.block = "block", t))(T || {});
const M = typeof window < "u", H = M && (window == null ? void 0 : window.matchMedia("(prefers-reduced-motion: reduce)").matches);
function F(t) {
  var e;
  return typeof window < "u" && window.navigator != null ? t.test(((e = window.navigator.userAgentData) == null ? void 0 : e.platform) || window.navigator.platform) : !1;
}
function L(t) {
  var e;
  return typeof window > "u" || window.navigator == null ? !1 : ((e = window.navigator.userAgentData) == null ? void 0 : e.brands.some(
    (r) => t.test(r.brand)
  )) || t.test(window.navigator.userAgent);
}
const k = F(/^Mac/i), W = L(/Android/i), m = L(/^((?!chrome|android).)*safari/i);
let N = -1;
const xt = (t) => `sf-${t}--${++N}`, yt = (t) => t.key === "Tab" && t.shiftKey, bt = (t) => t.key === "Tab" && !t.shiftKey, wt = () => {
};
function Lt(t, e, r) {
  return Math.min(Math.max(t, e), r);
}
function Dt(t, e) {
  return Math.round(t / e) * e;
}
function O(t, e) {
  if (t === e)
    return !0;
  const r = typeof t;
  if (r !== typeof e)
    return !1;
  if (r === "object" && t !== null && e !== null) {
    if (t.length !== e.length || Object.getOwnPropertyNames(t).length !== Object.getOwnPropertyNames(e).length)
      return !1;
    for (const n in t)
      if (!O(t[n], e[n]))
        return !1;
  } else
    return r === "function" ? t.toString() === e.toString() : !1;
  return !0;
}
const w = {
  reduceMotion: H,
  direction: u.horizontal
};
class Et {
  constructor(e, r) {
    a(this, "container");
    a(this, "options");
    a(this, "debounceId");
    a(this, "dragScrollX");
    a(this, "dragScrollLeft");
    a(this, "dragScrollY");
    a(this, "dragScrollTop");
    a(this, "pointerDownOffsetLeft");
    a(this, "pointerDownOffsetTop");
    a(this, "dragDistance");
    a(this, "isDraggedPreviously", !1);
    a(this, "resizeObserver", new ResizeObserver(() => {
      this.container && this.refresh(this.options.onScroll);
    }));
    if (!(e instanceof HTMLElement))
      throw new Error(`SfScrollable: Container is not a HTMLElement! Received: ${e}`);
    this.container = e, this.options = {
      ...r,
      reduceMotion: (r == null ? void 0 : r.reduceMotion) ?? w.reduceMotion,
      direction: (r == null ? void 0 : r.direction) ?? w.direction
    }, this.dragScrollX = 0, this.dragScrollLeft = 0, this.dragScrollY = 0, this.dragScrollTop = 0, this.pointerDownOffsetLeft = 0, this.pointerDownOffsetTop = 0, this.dragDistance = 0;
  }
  get isDragged() {
    return this.isDraggedPreviously;
  }
  set isDragged(e) {
    var r, s;
    e !== this.isDraggedPreviously && (this.isDraggedPreviously = e, (s = (r = this.options).onDragStart) == null || s.call(r, {
      isDragged: this.isDraggedPreviously
    }));
  }
  register() {
    const e = this.addListeners();
    return this.onScrollHandler(), e;
  }
  addListeners() {
    const e = this.onScroll.bind(this);
    if (this.container.addEventListener("scroll", e, { passive: !this.options.drag }), this.resizeObserver.observe(this.container), this.options.drag) {
      const r = this.onMouseDown.bind(this), s = this.onMouseUp.bind(this), n = this.onMouseMove.bind(this), o = this.onMouseLeave.bind(this);
      return this.container.addEventListener("mousedown", r, { passive: !1 }), this.container.addEventListener("mouseup", s, { passive: !0 }), this.container.addEventListener("mousemove", n, { passive: !1 }), this.container.addEventListener("mouseleave", o, { passive: !0 }), () => {
        this.container.removeEventListener("scroll", e), this.container.removeEventListener("mousedown", r), this.container.removeEventListener("mouseup", s), this.container.removeEventListener("mousemove", n), this.container.removeEventListener("mouseleave", o), this.resizeObserver.unobserve(this.container);
      };
    }
    return () => {
      this.container.removeEventListener("scroll", e), this.resizeObserver.unobserve(this.container);
    };
  }
  prev() {
    var n, o;
    let e = !1;
    if ((o = (n = this.options) == null ? void 0 : n.onPrev) == null || o.call(n, { preventDefault: () => e = !0 }), e)
      return;
    const { container: r, options: s } = this;
    s.direction === u.vertical ? this.scrollTo({ top: r.scrollTop - r.clientHeight }) : this.scrollTo({ left: r.scrollLeft - r.clientWidth });
  }
  next() {
    var n, o;
    let e = !1;
    if ((o = (n = this.options) == null ? void 0 : n.onNext) == null || o.call(n, { preventDefault: () => e = !0 }), e)
      return;
    const { container: r, options: s } = this;
    s.direction === u.vertical ? this.scrollTo({ top: r.scrollTop + r.clientHeight }) : this.scrollTo({ left: r.scrollLeft + r.clientWidth });
  }
  scrollToIndex(e) {
    const r = this.container.children;
    if (r[e]) {
      const { container: s } = this, { top: n, left: o } = s.getBoundingClientRect(), {
        top: l,
        left: d,
        width: c,
        height: f
      } = r[e].getBoundingClientRect();
      if (this.options.direction === u.vertical) {
        const h = l - n, g = (s.clientHeight - f) / 2;
        this.scrollTo({ top: s.scrollTop + h - g });
      } else {
        const h = d - o, g = (s.clientWidth - c) / 2;
        this.scrollTo({ left: s.scrollLeft + h - g });
      }
    }
  }
  refresh(e) {
    e && requestAnimationFrame(() => {
      e(this.calculate());
    });
  }
  onMouseUp(e) {
    var d, c;
    const { container: r, options: s } = this;
    this.isDragged = !1;
    const n = typeof this.options.drag == "object" && this.options.drag.sensitivity ? this.options.drag.sensitivity : 4, o = typeof this.options.drag == "object" ? this.options.drag.containerWidth : !1, l = 10;
    if (s.direction === u.vertical) {
      const h = (e.pageY - r.offsetTop - this.dragScrollY) * n;
      if (o) {
        if (Math.abs(this.dragDistance) < 10)
          return;
        r.scrollLeft = this.dragScrollLeft - (this.dragDistance < 0 ? r.clientHeight - l : -r.clientHeight + l);
      } else
        r.scrollTop = this.dragScrollTop - h;
    } else {
      const h = (e.pageX - r.offsetLeft - this.dragScrollX) * n;
      if (o) {
        if (Math.abs(this.dragDistance) < 10)
          return;
        r.scrollLeft = this.dragScrollLeft - (this.dragDistance < 0 ? r.clientWidth - l : -r.clientWidth + l);
      } else
        r.scrollLeft = this.dragScrollLeft - h;
    }
    (c = (d = this.options).onDragEnd) == null || c.call(d, {
      isDragged: !1,
      swipeLeft: this.dragDistance > -10,
      swipeRight: this.dragDistance < 10
    });
  }
  onMouseLeave() {
    this.isDragged = !1;
  }
  onMouseDown(e) {
    e.preventDefault();
    const { container: r, options: s } = this;
    this.isDragged = !0, this.pointerDownOffsetLeft = e.offsetX, this.pointerDownOffsetTop = e.offsetY, s.direction === u.vertical ? (this.dragScrollY = e.pageY - r.offsetTop, this.dragScrollTop = r.scrollTop) : (this.dragScrollX = e.pageX - r.offsetLeft, this.dragScrollLeft = r.scrollLeft);
  }
  onMouseMove(e) {
    if (!this.isDragged)
      return;
    e.preventDefault();
    const { options: r } = this;
    r.direction === u.vertical ? this.dragDistance = this.pointerDownOffsetTop - e.offsetY : this.dragDistance = this.pointerDownOffsetLeft - e.offsetX;
  }
  scrollTo({ left: e, top: r }) {
    const s = this.options.reduceMotion ? "auto" : "smooth";
    this.container.scrollTo({ left: e, top: r, behavior: s });
  }
  onScroll(e) {
    this.container && (this.options.drag && e.preventDefault(), clearTimeout(this.debounceId), this.debounceId = setTimeout(this.onScrollHandler.bind(this), 50));
  }
  onScrollHandler() {
    this.refresh(this.options.onScroll);
  }
  get hasNext() {
    return this.options.direction === u.vertical ? this.container.scrollHeight > this.container.scrollTop + this.container.clientHeight : this.container.scrollWidth > this.container.scrollLeft + this.container.clientWidth;
  }
  get hasPrev() {
    return this.options.direction === u.vertical ? !!this.container.scrollTop : !!this.container.scrollLeft;
  }
  calculate() {
    return {
      left: this.container.scrollLeft,
      width: this.container.clientWidth,
      scrollWidth: this.container.scrollWidth,
      hasPrev: this.hasPrev,
      hasNext: this.hasNext
    };
  }
}
var K = /* @__PURE__ */ ((t) => (t.neutral = "neutral", t.secondary = "secondary", t.positive = "positive", t.warning = "warning", t.error = "error", t))(K || {}), I = /* @__PURE__ */ ((t) => (t.temporary = "temporary", t.persistent = "persistent", t))(I || {}), X = /* @__PURE__ */ ((t) => (t.standard = "standard", t.dot = "dot", t))(X || {}), Y = /* @__PURE__ */ ((t) => (t["top-right"] = "top-right", t["top-left"] = "top-left", t["bottom-right"] = "bottom-right", t["bottom-left"] = "bottom-left", t))(Y || {}), j = /* @__PURE__ */ ((t) => (t.sm = "sm", t.base = "base", t.lg = "lg", t))(j || {}), G = /* @__PURE__ */ ((t) => (t.primary = "primary", t.secondary = "secondary", t.tertiary = "tertiary", t))(G || {}), C = /* @__PURE__ */ ((t) => (t.sm = "sm", t.base = "base", t))(C || {}), U = /* @__PURE__ */ ((t) => (t["3xs"] = "3xs", t["2xs"] = "2xs", t.xs = "xs", t.sm = "sm", t.base = "base", t.lg = "lg", t))(U || {}), A = /* @__PURE__ */ ((t) => (t.top = "top", t.bottom = "bottom", t.left = "left", t.right = "right", t))(A || {}), $ = /* @__PURE__ */ ((t) => (t.sm = "sm", t.base = "base", t.lg = "lg", t))($ || {}), q = /* @__PURE__ */ ((t) => (t.xs = "xs", t.sm = "sm", t.base = "base", t.lg = "lg", t.xl = "xl", t["2xl"] = "2xl", t["3xl"] = "3xl", t["4xl"] = "4xl", t))(q || {}), R = /* @__PURE__ */ ((t) => (t.primary = "primary", t.secondary = "secondary", t))(R || {}), J = /* @__PURE__ */ ((t) => (t.sm = "sm", t.base = "base", t.lg = "lg", t))(J || {}), Q = /* @__PURE__ */ ((t) => (t.xs = "xs", t.sm = "sm", t.base = "base", t.lg = "lg", t.xl = "xl", t["2xl"] = "2xl", t["3xl"] = "3xl", t["4xl"] = "4xl", t))(Q || {}), Z = /* @__PURE__ */ ((t) => (t.xs = "xs", t.sm = "sm", t.base = "base", t.lg = "lg", t.xl = "xl", t["2xl"] = "2xl", t["3xl"] = "3xl", t["4xl"] = "4xl", t))(Z || {}), _ = /* @__PURE__ */ ((t) => (t.xs = "xs", t.sm = "sm", t.base = "base", t.lg = "lg", t.xl = "xl", t))(_ || {}), V = /* @__PURE__ */ ((t) => (t.sm = "sm", t.base = "base", t.lg = "lg", t))(V || {}), B = /* @__PURE__ */ ((t) => (t.sm = "sm", t.base = "base", t.lg = "lg", t))(B || {}), P = /* @__PURE__ */ ((t) => (t.sm = "sm", t.base = "base", t.lg = "lg", t))(P || {}), z = /* @__PURE__ */ ((t) => (t.sm = "sm", t.base = "base", t.lg = "lg", t.xl = "xl", t))(z || {}), S = /* @__PURE__ */ ((t) => (t["top-start"] = "top-start", t.top = "top", t["top-end"] = "top-end", t["bottom-start"] = "bottom-start", t.bottom = "bottom", t["bottom-end"] = "bottom-end", t["left-start"] = "left-start", t.left = "left", t["left-end"] = "left-end", t["right-start"] = "right-start", t.right = "right", t["right-end"] = "right-end", t))(S || {}), tt = /* @__PURE__ */ ((t) => (t.fixed = "fixed", t.absolute = "absolute", t))(tt || {});
const x = (t, e) => e.findIndex((r) => r === t), et = (t, e) => {
  const r = x(t, e);
  return e[r + 1];
}, rt = (t, e) => {
  const r = x(t, e);
  return e[r - 1];
}, p = ({ focusables: t, event: e }) => {
  e == null || e.preventDefault();
  const r = t[0];
  return r == null || r.focus(), r;
}, b = ({ focusables: t, event: e }) => {
  e == null || e.preventDefault();
  const r = t[t.length - 1];
  return r == null || r.focus(), r;
}, st = (t, e) => {
  const r = et(t, e);
  return r == null || r.focus(), r;
}, nt = (t, e) => {
  const r = rt(t, e);
  return r == null || r.focus(), r;
}, ot = (t, e) => x(t, e) === 0, it = (t, e) => x(t, e) === e.length - 1, lt = (t, e, r) => {
  const s = [...r].reverse(), n = s.findIndex((o) => o === t);
  return s.find((o, l) => {
    var d;
    if (l > n && o.closest(e) && t.closest(e) !== o.closest(e) && ((d = s[l + 1]) == null ? void 0 : d.closest(e)) !== o.closest(e))
      return o;
  });
}, at = (t, e, r) => {
  const s = r.findIndex((n) => n === t);
  return r.find((n, o) => {
    if (o > s && n.closest(e) && t.closest(e) !== n.closest(e))
      return n;
  });
}, ct = ({
  current: t,
  focusables: e,
  arrowFocusGroupSelector: r
}) => {
  if (!t)
    return p({ focusables: e });
  const s = at(t, r, e);
  return t && s ? (s == null || s.focus(), s) : p({ focusables: e });
}, dt = ({
  current: t,
  focusables: e,
  arrowFocusGroupSelector: r
}) => {
  if (!t)
    return p({ focusables: e });
  const s = lt(t, r, e);
  return t && s ? (s == null || s.focus(), s) : b({ focusables: e });
}, ut = ({
  current: t,
  focusables: e,
  event: r
}) => {
  if (m && (r == null || r.preventDefault()), t) {
    if (it(t, e))
      return p({ focusables: e, event: r });
    if (m || !r)
      return st(t, e);
  } else
    return p({ focusables: e, event: r });
}, ht = ({
  current: t,
  focusables: e,
  event: r
}) => {
  if (m && (r == null || r.preventDefault()), t) {
    if (ot(t, e))
      return b({ focusables: e, event: r });
    if (m || !r)
      return nt(t, e);
  } else
    return b({ focusables: e, event: r });
}, Tt = ({
  current: t,
  event: e,
  focusables: r,
  arrowFocusGroupSelector: s
}) => s ? ct({ current: t, focusables: r, arrowFocusGroupSelector: s }) : ut({ current: t, focusables: r, event: e }), Mt = ({
  current: t,
  focusables: e,
  event: r,
  arrowFocusGroupSelector: s
}) => s ? dt({ current: t, focusables: e, arrowFocusGroupSelector: s }) : ht({ current: t, focusables: e, event: r });
function ft(t) {
  return t.mozInputSource === 0 && t.isTrusted ? !0 : W && t.pointerType ? t.type === "click" && t.buttons === 1 : t.detail === 0 && !t.pointerType;
}
function gt(t) {
  return !(t.metaKey || !k && t.altKey || t.ctrlKey || t.key === "Control" || t.key === "Shift" || t.key === "Meta");
}
const Ht = () => {
  let t = null;
  const e = /* @__PURE__ */ new Set();
  let r = !1, s = !1, n = !1;
  const o = () => t !== "pointer", l = (i, y) => {
    for (const v of e)
      v(i, y);
  }, d = (i) => {
    s = !0, gt(i) && (t = "keyboard", l("keyboard", i));
  }, c = (i) => {
    t = "pointer", (i.type === "mousedown" || i.type === "pointerdown") && (s = !0, l("pointer", i));
  }, f = (i) => {
    ft(i) && (s = !0, t = "virtual");
  }, h = (i) => {
    i.target === window || i.target === document || (!s && !n && (t = "virtual", l("virtual", i)), s = !1, n = !1);
  }, g = () => {
    s = !1, n = !0;
  };
  return {
    isFocusVisible: o,
    changeHandlers: e,
    setupGlobalFocusEvents: () => {
      if (typeof window > "u" || r)
        return;
      const i = HTMLElement.prototype.focus;
      HTMLElement.prototype.focus = function() {
        s = !0, i.apply(this, arguments);
      }, document.addEventListener("keydown", d, !0), document.addEventListener("keyup", d, !0), document.addEventListener("click", f, !0), window.addEventListener("focus", h, !0), window.addEventListener("blur", g, !1), typeof PointerEvent < "u" ? (document.addEventListener("pointerdown", c, !0), document.addEventListener("pointermove", c, !0), document.addEventListener("pointerup", c, !0)) : (document.addEventListener("mousedown", c, !0), document.addEventListener("mousemove", c, !0), document.addEventListener("mouseup", c, !0)), r = !0;
    },
    isKeyboardFocusEvent: (i, y, v) => !(i && y === "keyboard" && v instanceof KeyboardEvent && // Only Tab or Esc keys will make focus visible on text input elements
    !["Tab", "Escape"].includes(v.key))
  };
};
export {
  Et as Scrollable,
  I as SfAlertType,
  K as SfAlertVariant,
  Y as SfBadgePlacement,
  X as SfBadgeVariant,
  j as SfButtonSize,
  G as SfButtonVariant,
  C as SfChipSize,
  U as SfCounterSize,
  A as SfDrawerPlacement,
  q as SfIconSize,
  $ as SfInputSize,
  R as SfLinkVariant,
  J as SfListItemSize,
  Q as SfLoaderSize,
  S as SfPopoverPlacement,
  tt as SfPopoverStrategy,
  Z as SfProgressSize,
  V as SfRatingButtonSize,
  _ as SfRatingSize,
  T as SfScrollableButtonsPlacement,
  u as SfScrollableDirection,
  B as SfSelectSize,
  P as SfTextareaSize,
  z as SfThumbnailSize,
  Lt as clamp,
  O as equal,
  x as findCurrentFocusableIndex,
  et as findNextFocusable,
  rt as findPrevFocusable,
  p as focusFirstElement,
  b as focusLastElement,
  Tt as focusNext,
  st as focusNextElement,
  ut as focusNextOrFirst,
  Mt as focusPrev,
  nt as focusPrevElement,
  ht as focusPrevOrLast,
  Ht as focusVisibleManager,
  xt as generateId,
  W as isAndroid,
  M as isBrowser,
  ot as isCurrentFirstElement,
  it as isCurrentLastElement,
  k as isMac,
  H as isReduceMotionEnabled,
  m as isSafari,
  bt as isTab,
  yt as isTabAndShift,
  wt as noop,
  Dt as roundToNearest
};
